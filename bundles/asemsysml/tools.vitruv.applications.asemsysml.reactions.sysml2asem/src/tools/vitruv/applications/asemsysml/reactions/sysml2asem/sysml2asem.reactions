import edu.kit.ipd.sdq.ASEM.classifiers.Module
import org.eclipse.papyrus.sysml14.blocks.Block
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.Port
import org.eclipse.uml2.uml.PrimitiveType
import org.eclipse.uml2.uml.util.UMLUtil
import tools.vitruv.applications.asemsysml.ASEMSysMLHelper
import tools.vitruv.applications.asemsysml.ASEMSysMLPrimitiveTypeHelper
import tools.vitruv.applications.asemsysml.ASEMSysMLUserInteractionHelper

import "edu.kit.ipd.sdq.asem" as asem
import "http://www.eclipse.org/papyrus/sysml/1.4/SysML" as sysml
import "http://www.eclipse.org/uml2/5.0.0/UML" as uml

reactions: sysml2asem
in reaction to changes in uml
execute actions in asem

// TODO [BR] Only for debugging purposes.
reaction Debug {
	after any change
	call {
		logger.debug("[ASEMSysML] [Change] " + change);
	}
}

/*
 * SysML block reactions
 * ---------------------------------------------------------------------------------------------------
 */
reaction SysMLBlockCreated {
	
	after value replaced for sysml::Block[base_Class]
		with change.affectedEObject.encapsulated == true
	
	call {
		// A new SysML block was created. The isEncapsulated flag isn't set at this moment and its initial value is false.
		// So this reaction should never be called. The creation of the ASEM element will be done in the SysMLBlockIsEncapsulatedChanged reaction.
		val blocksBaseClass = change.newValue;
		val block = change.affectedEObject;
		val isEncapsulated = block.encapsulated;
		logger.info("[ASEMSysML] A SysML block was created! Its name is: " + blocksBaseClass.name + " and the isEncapsulated flag is: " + isEncapsulated);
		
	}
	
}

reaction SysMLBlockIsEncapsulatedChanged {
	
	after value replaced for sysml::Block[isEncapsulated]
		with change.newValue == true
		
	call {
		// The isEncapsulated flag of a SysMLBlock was set to true. Therefore create and persist the ASEM element.
		val block = change.affectedEObject;
		
		logger.info("[ASEMSysML] A SysML block (" + block.base_Class.name + ") was created and its isEncapsulated flag is true!");
		
		// Let user select the ASEM component to map the SysML block to.	
		val java.lang.Class<?> selectedComponentTypeClass = ASEMSysMLUserInteractionHelper.simulateUserInteractionForASEMComponentType(userInteracting);
		
		if (Module.isAssignableFrom(selectedComponentTypeClass)) {
			createASEMModelWithModuleAsRootElement(block);
		}
		else if (edu.kit.ipd.sdq.ASEM.classifiers.Class.isAssignableFrom(selectedComponentTypeClass)) {
			createASEMModelWithClassAsRootElement(block);
		}
		else {
			logger.info("[ASEMSysML] Invalid user selection for a ASEM component type.");
		}
		
	}
}
routine createASEMModelWithModuleAsRootElement(sysml::Block block) {
	action {
		val rootElement = create asem::Module and initialize {
			rootElement.name = block.base_Class.name;
			
			persistProjectRelative(block, rootElement, ASEMSysMLHelper.getASEMProjectModelPath(block.base_Class.name));
		}
		add correspondence between block and rootElement
	}
}
routine createASEMModelWithClassAsRootElement(sysml::Block block) {
	action {
		val rootElement = create asem::Class and initialize {
			rootElement.name = block.base_Class.name;
			
			persistProjectRelative(block, rootElement, ASEMSysMLHelper.getASEMProjectModelPath(block.base_Class.name));
		}
		add correspondence between block and rootElement
	}
}

reaction ChangeNameOfSysMLBlock {
	// After changing the name, the element will be persisted.
	// The old resource will be deleted by some magic of the VITRUV framework.
	 
	after value replaced for uml::Class[name]
		with change.affectedEObject.getAppliedStereotype("SysML::Blocks::Block") != null &&
			UMLUtil.getStereotypeApplication(change.affectedEObject, Block).isEncapsulated
	call {
		logger.info("[ASEMSysML] Change name of ASEM component ...");
		val block = UMLUtil.getStereotypeApplication(change.affectedEObject, Block);
		changeNameOfSysMLBlockCorrespondence(block)
	}
}
routine changeNameOfSysMLBlockCorrespondence(sysml::Block block) {
	match {
		val asemComponent = retrieve asem::Component corresponding to block	
	}	
	action {
		call {
			asemComponent.name = block.base_Class.name
			persistProjectRelative(block, asemComponent, ASEMSysMLHelper.getASEMProjectModelPath(block.base_Class.name));
		}
	}
}

/*
 * Port transformation
 * ---------------------------------------------------
 */
reaction PortTransformation {
	
	after value replaced for uml::Port[name]
		with change.affectedEObject.owner instanceof Class &&
			change.affectedEObject.owner.getAppliedStereotype("SysML::Blocks::Block") != null

	call {
		val port = change.affectedEObject
		logger.info("[ASEMSysML] Port with name " + change.newValue + " was created.");
		createPortCorrespondence(port);
	}
}
routine createPortCorrespondence(uml::Port port) {
	match {
		val asemModule = retrieve asem::Module corresponding to UMLUtil.getStereotypeApplication(port.owner, Block)
	}
	action {
		val asemMessage = create asem::Message and initialize {
			
			// [Requirement 1.d)i]
			asemMessage.name = port.name;
			
		}
		call {
			asemModule.typedElements.add(asemMessage)
		}
		add correspondence between port and asemMessage
	}
}

reaction PortDirectionTransformation {
	after value replaced for sysml::BindingConnector[base_Connector]
	call {
		val bindingConnector = change.affectedEObject;
		for(connectorEnds: bindingConnector.base_Connector.ends) {
			if(connectorEnds.role instanceof Port) {
				setMessageAccessProperties(connectorEnds.role as Port);
			}
		}
	}
}
routine setMessageAccessProperties(uml::Port port) {
	match {
		val asemMessage = retrieve asem::Message corresponding to port
	}
	action {
		call {
		
			// [Requirement 1.d)ii]
			val flowProperty = ASEMSysMLHelper.getFlowProperty(port);
			val flowDirection = flowProperty.direction;
			switch(flowDirection) {
				case IN: {
					asemMessage.readable = true;
					asemMessage.writable = false;
				}
				case INOUT: {
					asemMessage.readable = true;
					asemMessage.writable = true;
				}
				case OUT: {
					asemMessage.readable = false;
					asemMessage.writable = true;
				}
			}
			
		}
	}
}

reaction PortTypeTransformation {
	after value replaced for uml::Port[type]
	call {
		val port = change.affectedEObject;
		val block = UMLUtil.getStereotypeApplication(change.newValue, Block);
		
		if(block != null) {
			transformPortType(port, block);		
		} else if(change.newValue instanceof PrimitiveType) {
			transformPrimitivePortType(port);
		}
	}
}
routine transformPortType(uml::Port port, sysml::Block block){
	match {
		val asemMessage = retrieve asem::Message corresponding to port
		val asemComponent = retrieve asem::Component corresponding to block
	}
	action {
		call {
			
			// [Requirement 1.d)iii]
			asemMessage.type = asemComponent;
			
		}
	}
}
routine transformPrimitivePortType(uml::Port port) {
	match {
		val asemMessage = retrieve asem::Message corresponding to port
	}
	action {
		
		call {			
			val messageType = ASEMSysMLPrimitiveTypeHelper.PRIMITIVE_TYPE_MAP.get(port.type);
			asemMessage.type = ASEMSysMLPrimitiveTypeHelper.getASEMPrimitiveTypeFromRepository(messageType, asemMessage);
		}
	}
}

/*
 * Part transformation
 * ---------------------------------------------------
 */
 reaction PartTransformation {
 	// For the part transformation the part name and type are necessary.
 	// A property is a part property if
 	// 	- the containing element of the property is a block
 	// 	- the type of the property is a block
 	//	- the property is not a port
 	after value replaced for uml::Property[type]
 		with change.affectedEObject.eContainer instanceof Class &&
 		(change.affectedEObject.eContainer as Class).getAppliedStereotype("SysML::Blocks::Block") != null &&
 		change.newValue.getAppliedStereotype("SysML::Blocks::Block") != null &&
 		!(change.affectedEObject instanceof Port)
 		
 	call {
 		val partProperty = change.affectedEObject;
 		val blockBaseClass = partProperty.eContainer as Class;
 		logger.info("[ASEMSysML] Part " + partProperty.name + " for block " + blockBaseClass.name + " added.");
 		
 		createPartCorrespondence(partProperty, blockBaseClass);
 	}
 }
 routine createPartCorrespondence(uml::Property partProperty, uml::Class blockBaseClass) {
 	match {
 		// Corresponding ASEM element of the block.
 		val asemBlockComponent = retrieve asem::Component corresponding to UMLUtil.getStereotypeApplication(blockBaseClass, Block)
 		// Corresponding ASEM element of the part.
 		val asemPartComponent = retrieve asem::Component corresponding to UMLUtil.getStereotypeApplication(partProperty.type, Block)
 		
 		// ASEM modules cannot be used as subcomponents in ASEM components.
 		// TODO [BR] Show user feedback.	
 		check (asemPartComponent instanceof Module) == false
 	}
 	action {
 		val asemConstant = create asem::Constant and initialize {
 			asemConstant.name = partProperty.name;
 			asemConstant.type = asemPartComponent;
 		}
 		call {
 			asemBlockComponent.typedElements.add(asemConstant)
 		}
 		add correspondence between partProperty and asemConstant
 	}
 }

/*
 * SysML primitive type transformation
 * ---------------------------------------------------------------------------------------------------
 */
reaction PrimitiveTypeTransformation {
	after list entry created and inserted in uml::Model[packagedElement]
		with change.newValue instanceof PrimitiveType

	call {
		val primitiveType = change.newValue as PrimitiveType
		logger.info("[ASEMSysML] Primitive type " + primitiveType.name + " added.");
		
		// Add all ASEM primitive types to primitive types model.
		if(!ASEMSysMLPrimitiveTypeHelper.isPrimitiveTypeModelInitialized(primitiveType)) {
			logger.info("[ASEMSysML] Initialize primitive types for " + primitiveType.eResource);
			addASEMPrimitiveTypes(primitiveType);
		}
	}
}
routine addASEMPrimitiveTypes(uml::PrimitiveType primitiveType) {
	action {
		val pUnsignedDiscrete = create asem::UnsignedDiscreteType and initialize {
			pUnsignedDiscrete.name = "UnsignedDiscrete";
		}
		val pSignedDiscrete = create asem::SignedDiscreteType and initialize {
			pSignedDiscrete.name = "SignedDiscrete";
		}
		val pBoolean = create asem::BooleanType and initialize {
			pBoolean.name = "Boolean";
		}
		val pContinuous = create asem::ContinuousType and initialize {
			pContinuous.name = "Continuous";
		}
		val pRepo = create asem::PrimitiveTypeRepository and initialize {
			pRepo.name = "PrimitveTypeRepo";
			pRepo.primitiveTypes.add(pUnsignedDiscrete);
			pRepo.primitiveTypes.add(pSignedDiscrete);
			pRepo.primitiveTypes.add(pBoolean);
			pRepo.primitiveTypes.add(pContinuous);
			
			persistProjectRelative(primitiveType, pRepo, ASEMSysMLPrimitiveTypeHelper.primitiveTypeProjectModelPath);
		}
	}
}