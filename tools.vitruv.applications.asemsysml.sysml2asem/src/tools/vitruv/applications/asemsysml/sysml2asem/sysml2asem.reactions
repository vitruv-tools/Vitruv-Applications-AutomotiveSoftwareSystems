import edu.kit.ipd.sdq.ASEM.classifiers.Module
import java.util.ArrayList
import java.util.HashSet
import java.util.List
import java.util.Set
import org.eclipse.papyrus.sysml14.blocks.Block
import org.eclipse.uml2.uml.util.UMLUtil
import tools.vitruv.applications.asemsysml.sysml2asem.util.ASEMSysMLReactionHelper
import tools.vitruv.framework.userinteraction.UserInteractionType

import "edu.kit.ipd.sdq.asem" as asem
import "http://www.eclipse.org/papyrus/sysml/1.4/SysML" as sysml
import "http://www.eclipse.org/uml2/5.0.0/UML" as uml

reactions: sysml2asem
in reaction to changes in uml
execute actions in asem

// TODO [BR] Only for debugging purposes.
reaction Debug {
	after any change
	call {
		System.out.println("[ASEMSysML] [Change] " + change);
	}
}

reaction CreatedSysMLBlock {
	// Create corresponding ASEM element without a name, because changing the name is a separate change.
	// Therefore the ChangedNameOfSysMLBlock reaction is needed. The element will be persisted in the
	// ChangeNameOfSysMLBlock.
	
	// TODO [BR] Check if correspondence already exists.
	
	after list entry created and inserted in uml::Model[packagedElement]
		with change.newValue.getAppliedStereotype("SysML::Blocks::Block") != null 
			&& UMLUtil.getStereotypeApplication(change.newValue, Block).isEncapsulated
	
	call {
		
		System.out.println("[ASEMSysML] Create ASEM component ...");
		
		val changedClass = change.newValue;
		val block = UMLUtil.getStereotypeApplication(changedClass, Block);
			
		// Let user select the ASEM component to map the SysML block to.
		var Set<Class<?>> asemComponents = new HashSet
		asemComponents += #[Module, edu.kit.ipd.sdq.ASEM.classifiers.Class]
		
		val List<String> asemComponentNames = new ArrayList<String>(asemComponents.size)
		for (asemComponent : asemComponents) {
			asemComponentNames.add(asemComponent.name)
		}
		
		val String selectComponentMsg = "Please select an ASEM component type the SysML block should mapped to."
		val int selectedComponentType = userInteracting.selectFromMessage(UserInteractionType.MODAL, selectComponentMsg, asemComponentNames)
		val Class<?> selectedComponentTypeClass = asemComponents.get(selectedComponentType)
		
		createASEMModelWithRootElement(block, selectedComponentTypeClass.name);
	}
}

routine createASEMModelWithRootElement(sysml::Block block, String componentClassName) {
	action {
		call {
			// TODO [BR] Rework this part. Use classes instead of class names?
			if (componentClassName.equals("edu.kit.ipd.sdq.ASEM.classifiers.Module")) {
				createASEMModelWithModuleAsRootElement(block);
			}
			else if (componentClassName.equals("edu.kit.ipd.sdq.ASEM.classifiers.Class")) {
				// FIXME [BR] Class transformation is not yet supported.
				createASEMModelWithModuleAsRootElement(block);
			}
		}
	}
}

routine createASEMModelWithModuleAsRootElement(sysml::Block block) {
	action {
		val rootElement = create asem::Module		
		add correspondence between block and rootElement
	}
}

reaction ChangeNameOfSysMLBlock {
	// After changing the name, the element will be persisted.
	// The old resource will be deleted by some magic of the VITRUV framework.
	 
	after value replaced for uml::Class[name]
		with change.affectedEObject.getAppliedStereotype("SysML::Blocks::Block") != null &&
			UMLUtil.getStereotypeApplication(change.affectedEObject, Block).isEncapsulated
	call {
		System.out.println("[ASEMSysML] Change name of ASEM component ...");
		val block = UMLUtil.getStereotypeApplication(change.affectedEObject, Block);
		changeNameOfSysMLBlockCorrespondence(block)
	}
}
routine changeNameOfSysMLBlockCorrespondence(sysml::Block block) {
	match {
		val asemComponent = retrieve asem::Module corresponding to block	
	}	
	action {
		call {
			asemComponent.name = block.base_Class.name
			persistProjectRelative(block, asemComponent, ASEMSysMLReactionHelper.getASEMProjectModelPath(block.base_Class.name));
		}
	}
}